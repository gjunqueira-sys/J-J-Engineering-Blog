{
  
    
        "post0": {
            "title": "Signal Processing with Julia Language- Part 5",
            "content": "Sinusoidal Sequence . Defined as: . $$x(n) = sin(ω.n + φ), forall n in mathbb{ N}$$ . # Load dependencies using MySignalProcessing using Plots . . # with 100 samples every 2 full 2pi cycles s = 1.0 * sinseq(0,100, 0.125); . plot(s.n, s.A, line=:stem, title=&quot;Sinusoidal signal&quot;, marker = :o, color = :blue) . The same thing can be accomplished with the canonical form constructor:$$x[n]=sin( frac{M}{N} 2 pi n)$$ . #N = 100 s = 1.0 * sinseqmn(0,100, 2, 100); . plot(s.n, s.A, line=:stem, title=&quot;Sinusoidal signal&quot;, marker = :o, color = :black) . Signal Processing: . Take the above signal and &quot;rectify&quot; it by flipping negative half-cycles to positive. . # then going to take these negative cycles and flip polarity to positive cycles # and then add back to the original signal. # this will result in a signal with only positive cycles M= stepseq(0,25); . m1 = M |&gt; sigshift(25); m2 = M |&gt; sigshift(75); . p1 = plot(m1.n, m1.A, line=:stem, title=&quot;Step sequence&quot;, marker = :o, color = :red, xlims=(0,100)) p2 = plot(m2.n, m2.A, line=:stem, title=&quot;Step sequence&quot;, marker = :o, color = :red, xlims=(0,100)) plot(p1, p2, layout=(2,1)) . mask = m1+m2 . signal(Real[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 … 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], Real[25, 26, 27, 28, 29, 30, 31, 32, 33, 34 … 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) . s2 = s*mask . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … -0.9048270524660192, -0.8443279255020152, -0.7705132427757886, -0.6845471059286885, -0.587785252292472, -0.48175367410171477, -0.3681245526846781, -0.24868988716485388, -0.125333233564304, 1.2864981197413093e-15], Real[0, 1, 2, 3, 4, 5, 6, 7, 8, 9 … 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) . plot(s2.n, s2.A, line=:stem, title=&quot;Sinusoidal signal&quot;, marker = :o, color = :blue) . s3 = s + (-1*s*mask) + (-1*s*mask); . plot(s3.n, s3.A, line=:stem, title=&quot;Sinusoidal signal&quot;, marker = :o, color = :blue) . s3 = s + (-1*s*mask) + (-1*s*mask); s3 = s + (-2s*mask); . plot(s3.n, s3.A, line=:stem, title=&quot;Sinusoidal signal&quot;, marker = :o, color = :blue) . Decomposition and Synthesis . There are several important results in Discrete signal theory. One of them is the decomposition of signals into Even and Odd signals. . We define Even signals if : . $$Xₑ(-n) = Xₑ(n)$$ . Similarly , we define Odd signals if : . $$Xₒ(-n) = Xₒ(n)$$ . Any artibrary real-valued signal can be decomposed into Even and Odd signals: . $$x(n) = xₑ(n) + xₒ(n)$$ . where even and odd signals are given by: . $$xₑ(n) = frac{1}{2}[x(n) + x(-n)]$$ . $$Xₒ(n) = frac{1}{2}[x(n) - x(-n)]$$ . With our building block function we have already defined, we can now define the synthesis of the signal. . Let $$x(n) = u(n) -u(n-10)$$ , . Decompose it into Even and Odd signals: . x = stepseq(-30, 30) + (-1*stepseq(-20,20)|&gt; sigshift(10)) . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Real[-30, -29, -28, -27, -26, -25, -24, -23, -22, -21 … 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]) . plot(x.n, x.A, line=:stem, title=&quot;unit signal&quot;, marker = :o, color = :blue) . Xₑ = (1/2)* (x + (x |&gt; sigfold)); # pls see fold function definition . Xₒ = (1/2)* (x + -1*(x |&gt; sigfold)); # pls see fold function definition . p1 = plot(x.n, x.A, line=:stem, title=&quot;unit signal&quot;, marker = :o, color = :blue, label = &quot;x&quot;) p2 = plot(Xₑ.n, Xₑ.A, line=:stem, title=&quot;Even Part&quot;, marker = :o, color = :red, label = &quot;Xₑ&quot;) p3 = plot(Xₒ.n, Xₒ.A, line=:stem, title=&quot;Odd Part&quot;, marker = :o, color = :green, label = &quot;Xₒ&quot;) plot(p1, p2, p3, layout=(3,1)) .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/signalprocessing/2022/01/10/SignalProcessingPart5.html",
            "relUrl": "/jupyter/signalprocessing/2022/01/10/SignalProcessingPart5.html",
            "date": " • Jan 10, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Signal Processing with Julia Language- Part 4",
            "content": "Background Information . in previous posts we have seen how to create a signal with a given amplitude and sample range, as well as presented some basic functions for signal processing. Now we are ready to put these functions to good use. . For more information, pls see the following links: . For background information, pls see Signal Processing with Julia Language- Part I . In part 1 we discussed how to represent a signal, and constructor functions using my signal package in Julia. . My signal processing package can be found at MySignalProcessing.jl . # Load dependencies using MySignalProcessing using Plots . . Plot sequence as defined by the following equation: . $$x_1(n) = 2x(n-5) - 3x(n+4)$$ . given the signal $$x(n) = {1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1 } text{ , where } n= {-2, -1 , 0 , 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }$$ . The first part is obtained by shifting x(n) by +5 and the second part by shifting x(n) by -4. | . 1. Lets create the given signal first: . x = [1,2,3,4,5,6,7,6,5,4,3,2,1]; #amplitude vector n = [-2,-1,0,1,2,3,4,5,6,7,8,9,10]; #sample position vector s = signal(x,n) # create signal from the two vectors . signal(Real[1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1], Real[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) . 2. We can break it down the process in parts , just to visualize better: . # Original signal p1 = plot(s.n, s.A, line =:stem, marker=:o, color=:blue, label = &quot;s&quot;, ylims = (-10,15), xlims=(-10,20), framestyle = :origin,xtick=-10:20,ytick=-10:15) . . x₂ = 2.0 * ( s |&gt; sigshift(5) ) ; . plot(x₂.n, x₂.A, line =:stem, marker=:o, color=:red, label = &quot;x₂&quot;, ylims = (-10,15), xlims=(-10,20), framestyle = :origin, xtick=-10:20, ytick=-10:15) . . x₃ = -3.0 * ( s |&gt; sigshift(-4) ) . signal(Real[-3.0, -6.0, -9.0, -12.0, -15.0, -18.0, -21.0, -18.0, -15.0, -12.0, -9.0, -6.0, -3.0], Real[-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6]) . plot(x₃.n, x₃.A, line =:stem, marker=:o, color=:green, label = &quot;x₃&quot;, ylims = (-25,15), xlims=(-10,20), framestyle = :origin, xtick=-10:20, ytick=-25:15) . 3. Add the two signals x&#8322; and x&#8323; together: . x₁ = x₂ + x₃ . signal(Real[-3.0, -6.0, -9.0, -12.0, -15.0, -18.0, -21.0, -18.0, -15.0, -10.0 … 5.0, 10.0, 12.0, 14.0, 12.0, 10.0, 8.0, 6.0, 4.0, 2.0], Real[-6, -5, -4, -3, -2, -1, 0, 1, 2, 3 … 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) . plot(x₁.n, x₁.A, line =:stem, marker=:o, color=:black, label = &quot;x₁&quot;, ylims = (-25,15), xlims=(-10,20), framestyle = :origin, xtick=-10:20, ytick=-25:15) . . 4. Off course , we could have just written everything at once, just like the theory: . x₁ = 2.0 * ( s |&gt; sigshift(5) ) + (-3.0) * ( s |&gt; sigshift(-4) ) . x₁ = 2.0 * ( s |&gt; sigshift(5) ) + (-3.0) * ( s |&gt; sigshift(-4) ) . signal(Real[-3.0, -6.0, -9.0, -12.0, -15.0, -18.0, -21.0, -18.0, -15.0, -10.0 … 5.0, 10.0, 12.0, 14.0, 12.0, 10.0, 8.0, 6.0, 4.0, 2.0], Real[-6, -5, -4, -3, -2, -1, 0, 1, 2, 3 … 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) . p1 = plot(s.n, s.A, line =:stem, marker=:o, color=:blue, label = &quot;s&quot;, ylims = (-10,15), xlims=(-10,20), framestyle = :origin, xtick=-10:20, ytick=-10:15); p2 = plot(x₁.n, x₁.A, line =:stem, marker=:o, color=:black, label = &quot;x₁&quot;, ylims = (-25,15), xlims=(-10,20), framestyle = :origin, xtick=-10:20, ytick=-25:15); plot(p1,p2, layout = (2,1), size = (800,800)) . .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/signalprocessing/2022/01/10/SignalProcessingPart4.html",
            "relUrl": "/jupyter/signalprocessing/2022/01/10/SignalProcessingPart4.html",
            "date": " • Jan 10, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Signal Processing with Julia Language- Part 3",
            "content": "Background Information . Part 1 . For background information, pls see Signal Processing with Julia Language- Part I . In part 1 we discussed how to represent a signal, and constructor functions using my signal package in Julia. . My signal processing package can be found at MySignalProcessing.jl . Part 2 . Basic Functions Signal Processing with Julia Language- Part 2 . using MySignalProcessing using Plots . Signal add . We can add two signals together. However, we need to make sure that the signals have the same length. If sequences are of unequal lenghts or if the sample positions are different for equal-length sequences, the we cannot directly add. We have to first augment x1(n) and x2(n) , so that they have the same position vector n (and hence the same length). . Furtunally, the sigadd function does all that for us. . s1 = impseq(-10, 10); s2 = stepseq(-5, 15); . sigadd(s1, s2) . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], Real[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1 … 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) . p1 = plot(s1.n, s1.A, line =:stem, marker=:o) p2= plot(s2.n, s2.A, line =:stem, marker=:o) p3 = plot(sigadd(s1, s2).n, sigadd(s1, s2).A, line =:stem, marker=:o) plot(p1,p2,p3, layout=(3,1), xlims=(-10, 15)) . Julia language has a powerful multiple dispatch mechanism, which allows us to call a function based on the type of the arguments. Therefore, we can easily extend the Base.+ function to work with our signal package. This way, we can add two signals together : . signal1 + signal2 . s₃ = s1 + s2 #Base.+ Operator extended to work with our package . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], Real[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1 … 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) . p1 = plot(s1.n, s1.A, line =:stem, marker=:o) p2= plot(s2.n, s2.A, line =:stem, marker=:o) p3 = plot(s₃.n, s₃.A, line =:stem, marker=:o) plot(p1,p2,p3, layout=(3,1), xlims=(-10, 15)) . Signal Shift . Julia is known for the highly composable nature of its language. Meaning that functions can be composed of other functions and we can use the output of one function as the input of another. This leads to a very powerful tool for signal processing. Hopefully you are starting to see the elegance in which Julia is able to do this. . s = impseq(-10, 10); sshifted = s |&gt; sigshift(5) # |&gt; is the pipe operator, piping the signal through a function and shifting it by 5 samples . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Real[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4 … 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) . The same thing could also be written as: . sigshift(5) ∘ s # this is the same as the above, however, we compose from right to left . MySignalProcessing.var&#34;#1#2&#34;{Int64}(5) ∘ signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Real[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1 … 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) . p1 = plot(s.n, s.A, line =:stem, marker=:o) p2 = plot(sshifted.n, sshifted.A, line =:stem, marker=:o) fig3 = plot(p1,p2, layout=(1,2)) display(fig3) . Signal Multiply . s1 = stepseq(-10, 10) |&gt; sigshift(-5); s2 = signal(0.0, -15, 15); s3 = sigadd(s1,s2); . p1 = plot(s1.n, s1.A, line =:stem, marker=:o, xlims=(-15,15)) p2 = plot(s2.n, s2.A, line =:stem, marker=:o, xlims=(-15,15)) p3 = plot(s3.n, s3.A, line =:stem, marker=:o, xlims=(-15,15)) plot(p1,p2,p3, layout=(3,1)) . s4 = signal(1.0, -15, 15); s5 = signal(0.0, -15, 15); s5.A = rand.().*s4.A; . p5 = plot(s5.n, s5.A, line =:stem, marker=:o, xlims=(-15,15), ylims=(0,1)) . Signal Multiplication: Function to multiply two signal s1 and s2. pls note that the signals must have the same length. If sequences are of unequal lenghts or if the sample positions are different for equal-length sequences, the we cannot directly add. We have to first augment x1(n) and x2(n) , so that they have the same position vector n (and hence the same length). . The amplitude of the resulting signal is the product of the amplitudes of the two signals, element-wise. . s6 = sigmult(s5, s3) . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Real[-15, -14, -13, -12, -11, -10, -9, -8, -7, -6 … 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) . p1 = plot(s3.n, s3.A, line =:stem, marker=:o, xlims=(-15,15)) p2 = plot(s5.n, s5.A, line =:stem, marker=:o, xlims=(-15,15)) p3 = plot(s6.n, s6.A, line =:stem, marker=:o, xlims=(-15,15)) plot(p1,p2,p3, layout=(3,1)) . Just like the signal add, we have also extended Base.* to work with our signal package: . s7 = s5 * s3 . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Real[-15, -14, -13, -12, -11, -10, -9, -8, -7, -6 … 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) . p1 = plot(s3.n, s3.A, line =:stem, marker=:o, xlims=(-15,15), color=:blue) p2 = plot(s5.n, s5.A, line =:stem, marker=:o, xlims=(-15,15), color=:black) p3 = plot(s7.n, s7.A, line =:stem, marker=:o, xlims=(-15,15), color=:red) plot(p1,p2,p3, layout=(3,1)) . With some very basic functions, we can already do some pretty interesting things. Next post, we will really build on these functions to get into applications and see how they can be used in signal processing. .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/signalprocessing/2022/01/10/SignalProcessingPart3.html",
            "relUrl": "/jupyter/signalprocessing/2022/01/10/SignalProcessingPart3.html",
            "date": " • Jan 10, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Hyperledger- Challenges and Solutions",
            "content": "Introduction . Blockchain technology is one of the most exciting innovations to come out in recent years. . Blockchain technology has been applied as a digital ledger, where all transactions are recorded and shared among networks. A blockchain allows for every party on the network to have a copy of any given record with no risk that someone can alter it without being detected. . This new public blockchain ledger has been developed specifically for use by large enterprises who want to take advantage of its features but may not be able to afford the high initial cost or technical know-how required for building their own system from scratch. In this blog post, we will discuss what a public blockchain is and how it works so you can decide if your business should implement this innovative technology into your infrastructure! . The Hyperledger . is a non-profit foundation that aims to advance cross-industry blockchain technologies. late last year, they announced the release of their new open source public blockchain ledger called Sawtooth Lake. Sawtooth Lake is designed for businesses who want to take advantage of the benefits offered by blockchains but don’t want to build their own system from scratch. . This blockchain has designed a Corporate Business layer on top of the blockchain in order to make it more user-friendly for businesses to adopt. The CBDL is a permissioned blockchain that allows businesses to control the who, what, and when of transactions on the ledger. . The Hyperledger Sawtooth Lake public blockchain ledger has many features that make it an attractive option for businesses looking to implement a blockchain solution. For example, it provides modularity as it is expected that a cross-industry blockchain will be used in many business scenarios , so functions such as storage, policy, access controls and others should be modular. . Another important factor is privacy and confidentiality, as it is the utmost importance that transactions on the network are visible only to those allowed to view it. Many other factors such as Identity, scalability, deterministic transactions, auditability, portability are considered. . How Businesses can Benefit from the Hyperledger . from the new public blockchain ledger: . -The ledger provides a highly secure and trusted environment for businesses to conduct transactions. It helps eliminate fraud as all transactions are irreversible once they have been validated by consensus across network nodes. This eliminates any possibilities of reversing already confirmed blocks, which is one of the main benefits that come along with using blockchain technology. . This also minimizes or completely removes human error from transactional processes since it is executed automatically after pre-defined rules and conditions within smart contracts on the blockchain , this saves time and money spent on employees performing manual tasks such as reconciliation between two ledgers in different networks . Finally, there is no need to establish trust among partners because everything works autonomously through code. . Challenges . Of course, implementing a successful corporate Hyperledger can be a dauting task. The first challenge would be to convince your organization that the benefits of blockchain technology outweigh its disadvantages. . The biggest obstacle is often convincing management teams and boards of directors that there are real business use cases for Hyperledger within their organizations because it’s important to note blockchain is still in its infancy . This means many people don’t really understand what exactly this new type of ledger can do or how it works, so they naturally resist changes. Once you have a solid understanding on how Hyperledger will benefit your company , then the next step involves deciding which components from the stack need to be used by each department within an organization . Some companies may just opt for using smart contracts while others may not see much value until more advanced features such as data privacy and security is rock-solid. This is when a consulting company such as J&amp;J Engineering can help put together a solid business-case and requirements for successful implementation. . Conclusion . : Blockchain is a new technology that has the potential to disrupt and revolutionize how we manage our information, but it will take time for this world-changing technology to be adopted by all businesses. . If you are interested in learning more about blockchain or if you would like help setting up your own private blockchain then please get in touch with J&amp;J Engineering today! We offer both Hyperledger workshops as well as custom solutions development services . .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/blockchain/2022/01/09/Blockchainpost.html",
            "relUrl": "/blockchain/2022/01/09/Blockchainpost.html",
            "date": " • Jan 9, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Signal Processing with Julia Language- Part 2",
            "content": "Background Information - Part 1 . For background information, pls see Signal Processing with Julia Language- Part I . In part 1 we discussed how to represent a signal, and constructor functions using my signal package in Julia. . My signal processing package can be found at MySignalProcessing.jl . using MySignalProcessing using Plots . Basic Signal Processing Functions . In part 2 we will discuss some basic signal processing functions and how to create them for further manipulation. . Unit impulse signal . This sequence is defined as: . $$ delta(n) = begin{cases} 1 &amp; text{ if } n = 0 0 &amp; text{otherwise} end{cases}$$ . s = impseq(-10, 10); #create imp. sequence, -10 to 10 fig1 = plot(s.n, s.A, line =:stem, marker=:o) . Unit Step Sequence . This sequence is defined as: . $$u(n) = begin{cases} 1 &amp; text{ if } n geq 0 0 &amp; text{otherwise} end{cases}$$ . s = stepseq(-5, 10); fig2 = plot(s.n, s.A, line =:stem, marker=:o) . sigrand Function - Generates a random signal . s1 = sigrand(-15,10); #create random signal, -15 to 10 plot(s1.n, s1.A, line=:stem, color=:red, marker=:o, xlims=(-15,10)) . Real-Valued Exponential Signal . This function is defined as: . $$r(a, n) = a^n$$ . s = realexp(1.1, -50, 50); plot(s.n, s.A, line =:stem, marker=:o) . s = realexp(0.9, -50, 50); plot(s.n, s.A, line =:stem, marker=:o) .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/signalprocessing/2021/12/31/SignalProcessingPart2.html",
            "relUrl": "/jupyter/signalprocessing/2021/12/31/SignalProcessingPart2.html",
            "date": " • Dec 31, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "CoinGecko API Wrapper in Julia Language - Part 1",
            "content": "Basic API Documentation and Installation Information . One of the most powerfull crypto API&#39;s out there. APIs are simple and easy to use, fully documented at the website. . (&quot;CoinGecko API&quot; is a trademark of CoinGecko) . API Information: . CoinGecko API . Julia API Wrapper Package information: . Pls check my package information at the website for code and documentation. . gjunqueira-sys / CoinGeckoAPI . Example Use: Get top 10 coins by Market Cap . # Load dependancies using CoinGeckoAPI; using Plots; . . # check API documentation for more information - we are interested in the /coins/markets function call for this example # https://www.coingecko.com/en/api/documentation # call the API, market cap in USD, optional arguments are: # order: &quot;market_cap_desc&quot; # per_page: 10 # page: 1 # We are getting only the top 10 market caps r = get_coins_markets(&quot;usd&quot;, &quot;order&quot; =&gt; &quot;market_cap_desc&quot;, &quot;per_page&quot; =&gt; &quot;10&quot;, &quot;page&quot; =&gt; &quot;1&quot;); . Now lets look at the output closer: . length(r) . 10 . r |&gt; length #or call the same function but with the pipe operator, my preference! . 10 . r |&gt; typeof # this is a vector output, with length 10 . JSON3.Array{JSON3.Object, Base.CodeUnits{UInt8, String}, Vector{UInt64}} . we can check the first element: . r[1] . JSON3.Object{Base.CodeUnits{UInt8, String}, SubArray{UInt64, 1, Vector{UInt64}, Tuple{UnitRange{Int64}}, true}} with 26 entries: :id =&gt; &#34;bitcoin&#34; :symbol =&gt; &#34;btc&#34; :name =&gt; &#34;Bitcoin&#34; :image =&gt; &#34;https://assets.coingecko.com/coins/imag… :current_price =&gt; 48141 :market_cap =&gt; 907941443592 :market_cap_rank =&gt; 1 :fully_diluted_valuation =&gt; 1008064470982 :total_volume =&gt; 28281205085 :high_24h =&gt; 48990 :low_24h =&gt; 46648 :price_change_24h =&gt; -848.983 :price_change_percentage_24h =&gt; -1.73296 :market_cap_change_24h =&gt; -1.88657e10 :market_cap_change_percentage_24h =&gt; -2.03556 :circulating_supply =&gt; 18914237 :total_supply =&gt; 21000000 :max_supply =&gt; 21000000 :ath =&gt; 69045 ⋮ =&gt; ⋮ . Now let us get all the keys and values pairs: . keys(r[1]) . KeySet for a JSON3.Object{Base.CodeUnits{UInt8, String}, SubArray{UInt64, 1, Vector{UInt64}, Tuple{UnitRange{Int64}}, true}} with 26 entries. Keys: :id :symbol :name :image :current_price :market_cap :market_cap_rank :fully_diluted_valuation :total_volume :high_24h :low_24h :price_change_24h :price_change_percentage_24h :market_cap_change_24h :market_cap_change_percentage_24h :circulating_supply :total_supply :max_supply :ath ⋮ . values(r[1]) . ValueIterator for a JSON3.Object{Base.CodeUnits{UInt8, String}, SubArray{UInt64, 1, Vector{UInt64}, Tuple{UnitRange{Int64}}, true}} with 26 entries. Values: &#34;bitcoin&#34; &#34;btc&#34; &#34;Bitcoin&#34; &#34;https://assets.coingecko.com/coins/images/1/large/bitcoin.png?1547033579&#34; 48141 907941443592 1 1008064470982 28281205085 48990 46648 -848.982844209088 -1.73296 -1.8865720467968506e10 -2.03556 18914237 21000000 21000000 69045 ⋮ . For this example, we are only interested in name and market cap. . We can use the following code to push names and values to vectors for plotting: . Vₙ = [];# name vector Mc = []; #value vector for i in 1:length(r) push!(Vₙ, r[i][&quot;id&quot;]); #get vector with names push!(Mc, r[i][&quot;market_cap&quot;]); #get vector with market caps end . bar(Vₙ, Mc, title = &quot;top 10 coins market cap&quot;, ylabel=&quot;Market cap&quot;, xrotation= 45 ) #plot market caps . That&#39;s it! .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/julialang/crypto/2021/12/29/BasicAPIBlogPart1.html",
            "relUrl": "/jupyter/julialang/crypto/2021/12/29/BasicAPIBlogPart1.html",
            "date": " • Dec 29, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Symbolic Euler's Method",
            "content": "# load dependacies using MyCalculus using Plots using Symbolics . . Apply Euler&#39;s method for the following First-Order Differential Equation: . $fun(t, y) = y^2 -t$ . fun(t, y) = y^2 -t . fun (generic function with 1 method) . Definition of Euler&#39;s Method function: . $EulerMethod(f, x₀, y₀, step= 0.5, n=100.0)$ . Function to approximate solution to an ordinary differential equation using the Euler&#39;s Method. dy/dx = f(x, y) where y(x₀) = y₀ and x₀ = x₀. . Arguments . $f:$ function to approximate solution to, of the form f(x, y). This is the right hand side of the differential equation. . | $x₀:$ initial $x$ value condition | $y₀:$ initial $y$ value condition | $step:$ step size for the Euler&#39;s Method | $n:$ number of steps to take | . Returns . $x:$ array of x values | $y:$ array of y values | . x, y = EulerMethod(fun, -1.0, -0.5, 0.5, 5) . ([-1.0, -0.5, 0.0, 0.5, 1.0], [-0.5, 0.125, 0.3828125, 0.456085205078125, 0.31009206222370267]) . plot(x,y, ylim=(-0.5,0.5), xlim=(-1,1), framestyle = :, ylabel = &quot;y&quot;, xlabel = &quot;x&quot;) . We can also use Symbolics by passing Symbolics variables to the function: . This is a good way to &quot;peek&quot; into the inner workings of the Euler&#39;s Method and see what it&#39;s doing for every iteration. . It also showcases the power of Symbolics. Due to highly composable julia code, we can use Symbolics everywhere a number is expected. . @variables x₀, y₀, step #defines the symbollics variables t, y = EulerMethod(fun, x₀, y₀, step, 5) . (Num[x₀, step + x₀, x₀ + 2step, x₀ + 3step, x₀ + 4step], Num[y₀, y₀ + step*(y₀^2 - x₀), y₀ + step*(y₀^2 - x₀) + step*((y₀ + step*(y₀^2 - x₀))^2 - step - x₀), y₀ + step*(y₀^2 - x₀) + step*((y₀ + step*(y₀^2 - x₀))^2 - step - x₀) + step*((y₀ + step*(y₀^2 - x₀) + step*((y₀ + step*(y₀^2 - x₀))^2 - step - x₀))^2 - 2step - x₀), y₀ + step*(y₀^2 - x₀) + step*((y₀ + step*(y₀^2 - x₀))^2 - step - x₀) + step*((y₀ + step*(y₀^2 - x₀) + step*((y₀ + step*(y₀^2 - x₀))^2 - step - x₀))^2 - 2step - x₀) + step*((y₀ + step*(y₀^2 - x₀) + step*((y₀ + step*(y₀^2 - x₀))^2 - step - x₀) + step*((y₀ + step*(y₀^2 - x₀) + step*((y₀ + step*(y₀^2 - x₀))^2 - step - x₀))^2 - 2step - x₀))^2 - 3step - x₀)]) . t; . begin{equation} left[ begin{array}{c} x{_0} step + x{_0} x{_0} + 2 step x{_0} + 3 step x{_0} + 4 step end{array} right] end{equation} y; . $$ begin{equation} left[ begin{array}{c} y{_0} y{_0} + step left( - x{_0} + y{_0}^{2} right) y{_0} + step left( - x{_0} + y{_0}^{2} right) + step left( - step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) right)^{2} right) y{_0} + step left( - x{_0} + y{_0}^{2} right) + step left( - step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) right)^{2} right) + step left( - 2 step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) + step left( - step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) right)^{2} right) right)^{2} right) y{_0} + step left( - x{_0} + y{_0}^{2} right) + step left( - step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) right)^{2} right) + step left( - 2 step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) + step left( - step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) right)^{2} right) right)^{2} right) + step left( - 3 step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) + step left( - step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) right)^{2} right) + step left( - 2 step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) + step left( - step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) right)^{2} right) right)^{2} right) right)^{2} right) end{array} right] end{equation}$$ .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/math/calculus/symbolics/julialang/2021/12/28/EulersMethod.html",
            "relUrl": "/jupyter/math/calculus/symbolics/julialang/2021/12/28/EulersMethod.html",
            "date": " • Dec 28, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "Signal Processing with Julia Language- Part I",
            "content": "Installation . This notebook will make use of my package located at MySignalProcessing.jl. . For installation, please follow the instructions in the README.md file at my github repository. . Signal Constructors . In these examples, we deal with Discrete Signals only. Discrete Signal, are most often used in the context of digital communication and have many applications in various engineering fields. . A discrete signal is a sequence of samples, each of which is a value of a specific type. . The correct way to represent a discrete signal is to use two vectors: . x: the time vector of the signal (horizontal axis), or in the discete case, the vector of the indices of the samples (n) | y: the values of the signal (vertical axis), or its amplitude, at each of the samples (n). | . As such, I define a custom type, namely Signal, which is a structure that contains the two vectors above. . It has a .A fieldname, which is the amplitude of the signal and a .n fieldname, which is the sample vector. . mutable struct signal A::Vector{Real} #Amplitude of the signal n::Vector{Real} #horizontal axis (discrete) of signal (in samples) end . signal(A::Real, n::Int) Constructor . using MySignalProcessing using Plots . . s = signal(1.5, 10) # create a signal with amplitude 1.5 and number of samples 10, starting from sample 0 . signal(Real[1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5], Real[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) . We can now check the fieldnames of signal s: . s |&gt; typeof . signal . s |&gt; typeof |&gt; fieldnames . (:A, :n) . s.A |&gt; println . Real[1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5] . s.n |&gt; println . Real[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . plot(s.n, s.A, line= :stem, title = &quot;Signal&quot;, marker=:o, size=(400,300), ylabel=&quot;Amplitude&quot;, xlabel=&quot;Sample&quot;) . signal(A::Real, start::Int, stop::Int) Constructor . s1 = signal(π , -5,7) # create a signal with amplitude pi , starting from sample -5 and ending at sample 7 . signal(Real[3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793], Real[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7]) . plot(s1.n, s1.A, line= :stem, title = &quot;Signal&quot;, marker=:o, size=(400,300), ylabel=&quot;Amplitude&quot;, xlabel=&quot;Sample&quot;) . signal(A::Vector, n::Vector) Constructor . With this constructor, we can buld a signal by passing two vectors to the function, one for the amplitude and one for the sample vector. . A = rand(4); n = [-1, 0, 1, 2]; s3 = signal(A, n); . plot(s3.n, s3.A, line= :stem, title = &quot;Signal&quot;, marker=:o, size=(400,300), ylabel=&quot;Amplitude&quot;, xlabel=&quot;Sample&quot;) . The signal type is the basic building block for various functions. Now you have a good understanding of the basic structure of a signal. .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/signalprocessing/2021/12/27/SignalProcessingPart1.html",
            "relUrl": "/jupyter/signalprocessing/2021/12/27/SignalProcessingPart1.html",
            "date": " • Dec 27, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "First Blog Post",
            "content": "First Blog Post . Using a new platform to write and publish my blog posts. This is the first post. Most writers post their content to platforms such as Medium. But I wanted to try something new. Fastpages is a new platform that I’m using to write and publish my content. Unlike Medium, my content created is under my control and repository. 😄 .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/markdown/2021/12/26/FirstPost.html",
            "relUrl": "/markdown/2021/12/26/FirstPost.html",
            "date": " • Dec 26, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "J&amp;J Engineering is a company with more than 10 years in the field of Manufacturing, Automation, Electrical and Software design. . We are your partner for all your automation needs: . Autocad and Electrical Drawings and design; | PE Stamping; | PLC Programming and Automation; | Software and Functional Specifications; | Descriptions of Operations; | Project Management and Project Management consulting and Audits; | Electrical Cabinet Design; | Whole Product design lifecycle. | . We are also on the forefront of the new Web 3.0. Our experienced software engineers can support and guide your strategies into this new technology: . Auditing smart contracts and ICO consulting services, you can be assured that we have the knowledge to assist you with any blockchain related project. Our team has experience working on different industries including retail, manufacturing, chemicals, oil &amp; gas and others. . We provide competitive pricing for all of our products because we believe that everyone deserves access to high quality engineering solutions at affordable prices which will not compromise their safety or wellbeing. . We are committed to providing excellent service by always being available when needed so contact us today! . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}