{
  
    
        "post0": {
            "title": "Formula One Data Exploration - Part I",
            "content": "using DataFrames using CSV using Plots using Statistics using StatsPlots using Shapefile # using ZipFile . . # for f in r.files # println(&quot;Filename: $(f.name)&quot;) # open(f.name, &quot;w&quot;) do io # write(io, read(f)) # end # end # close(r) . shp_countries = Shapefile.shapes(Shapefile.Table(&quot;./ne_110m_admin_0_countries.shp&quot;)); . Load data from csv . df_drivers = CSV.read(&quot;drivers.csv&quot;, DataFrame); df_circuits = CSV.read(&quot;circuits.csv&quot;, DataFrame); df_results = CSV.read(&quot;results.csv&quot;, DataFrame); df_races = CSV.read(&quot;races.csv&quot;, DataFrame); df_constructors = CSV.read(&quot;constructors.csv&quot;, DataFrame); . Sample and describe data . first(df_drivers, 5) #show first 5 . 5 rows × 9 columns (omitted printing of 1 columns) . driverIddriverRefnumbercodeforenamesurnamedobnationality . Int64String31String3String3String31String31DateString31 . 11 | hamilton | 44 | HAM | Lewis | Hamilton | 1985-01-07 | British | . 22 | heidfeld | N | HEI | Nick | Heidfeld | 1977-05-10 | German | . 33 | rosberg | 6 | ROS | Nico | Rosberg | 1985-06-27 | German | . 44 | alonso | 14 | ALO | Fernando | Alonso | 1981-07-29 | Spanish | . 55 | kovalainen | N | KOV | Heikki | Kovalainen | 1981-10-19 | Finnish | . df_drivers |&gt; describe . 9 rows × 7 columns (omitted printing of 3 columns) . variablemeanminmedian . SymbolUnion…AnyAny . 1driverId | 427.554 | 1 | 427.5 | . 2driverRef | | Cannoc | | . 3number | | 10 | | . 4code | | AIT | | . 5forename | | Adolf | | . 6surname | | Abate | | . 7dob | | 1896-12-28 | 1936-12-28 | . 8nationality | | American | | . 9url | | http://en.wikipedia.org/wiki/%C3%89lie_Bayol | | . first(df_circuits, 5) #show first 5 . 5 rows × 9 columns (omitted printing of 4 columns) . circuitIdcircuitRefnamelocationcountry . Int64String15StringString31String15 . 11 | albert_park | Albert Park Grand Prix Circuit | Melbourne | Australia | . 22 | sepang | Sepang International Circuit | Kuala Lumpur | Malaysia | . 33 | bahrain | Bahrain International Circuit | Sakhir | Bahrain | . 44 | catalunya | Circuit de Barcelona-Catalunya | Montmeló | Spain | . 55 | istanbul | Istanbul Park | Istanbul | Turkey | . df_circuits |&gt; describe . 9 rows × 7 columns (omitted printing of 2 columns) . variablemeanminmedianmax . SymbolUnion…AnyUnion…Any . 1circuitId | 40.0 | 1 | 40.0 | 79 | . 2circuitRef | | BAK | | zolder | . 3name | | A1-Ring | | Zolder | . 4location | | Abu Dhabi | | Zandvoort | . 5country | | Argentina | | Vietnam | . 6lat | 33.519 | -37.8497 | 40.9517 | 57.2653 | . 7lng | 3.09617 | -118.189 | 4.32694 | 144.968 | . 8alt | | -7 | | N | . 9url | | http://en.wikipedia.org/wiki/A1-Ring | | http://en.wikipedia.org/wiki/Zolder | . df_circuits[:,4:end] . 79 rows × 6 columns . locationcountrylatlngalturl . String31String15Float64Float64String7String . 1Melbourne | Australia | -37.8497 | 144.968 | 10 | http://en.wikipedia.org/wiki/Melbourne_Grand_Prix_Circuit | . 2Kuala Lumpur | Malaysia | 2.76083 | 101.738 | 18 | http://en.wikipedia.org/wiki/Sepang_International_Circuit | . 3Sakhir | Bahrain | 26.0325 | 50.5106 | 7 | http://en.wikipedia.org/wiki/Bahrain_International_Circuit | . 4Montmeló | Spain | 41.57 | 2.26111 | 109 | http://en.wikipedia.org/wiki/Circuit_de_Barcelona-Catalunya | . 5Istanbul | Turkey | 40.9517 | 29.405 | 130 | http://en.wikipedia.org/wiki/Istanbul_Park | . 6Monte-Carlo | Monaco | 43.7347 | 7.42056 | 7 | http://en.wikipedia.org/wiki/Circuit_de_Monaco | . 7Montreal | Canada | 45.5 | -73.5228 | 13 | http://en.wikipedia.org/wiki/Circuit_Gilles_Villeneuve | . 8Magny Cours | France | 46.8642 | 3.16361 | 228 | http://en.wikipedia.org/wiki/Circuit_de_Nevers_Magny-Cours | . 9Silverstone | UK | 52.0786 | -1.01694 | 153 | http://en.wikipedia.org/wiki/Silverstone_Circuit | . 10Hockenheim | Germany | 49.3278 | 8.56583 | 103 | http://en.wikipedia.org/wiki/Hockenheimring | . 11Budapest | Hungary | 47.5789 | 19.2486 | 264 | http://en.wikipedia.org/wiki/Hungaroring | . 12Valencia | Spain | 39.4589 | -0.331667 | 4 | http://en.wikipedia.org/wiki/Valencia_Street_Circuit | . 13Spa | Belgium | 50.4372 | 5.97139 | 401 | http://en.wikipedia.org/wiki/Circuit_de_Spa-Francorchamps | . 14Monza | Italy | 45.6156 | 9.28111 | 162 | http://en.wikipedia.org/wiki/Autodromo_Nazionale_Monza | . 15Marina Bay | Singapore | 1.2914 | 103.864 | 18 | http://en.wikipedia.org/wiki/Marina_Bay_Street_Circuit | . 16Oyama | Japan | 35.3717 | 138.927 | 583 | http://en.wikipedia.org/wiki/Fuji_Speedway | . 17Shanghai | China | 31.3389 | 121.22 | 5 | http://en.wikipedia.org/wiki/Shanghai_International_Circuit | . 18São Paulo | Brazil | -23.7036 | -46.6997 | 785 | http://en.wikipedia.org/wiki/Aut%C3%B3dromo_Jos%C3%A9_Carlos_Pace | . 19Indianapolis | USA | 39.795 | -86.2347 | 223 | http://en.wikipedia.org/wiki/Indianapolis_Motor_Speedway | . 20Nürburg | Germany | 50.3356 | 6.9475 | 578 | http://en.wikipedia.org/wiki/N%C3%BCrburgring | . 21Imola | Italy | 44.3439 | 11.7167 | 37 | http://en.wikipedia.org/wiki/Autodromo_Enzo_e_Dino_Ferrari | . 22Suzuka | Japan | 34.8431 | 136.541 | 45 | http://en.wikipedia.org/wiki/Suzuka_Circuit | . 23Spielberg | Austria | 47.2197 | 14.7647 | 678 | http://en.wikipedia.org/wiki/A1-Ring | . 24Abu Dhabi | UAE | 24.4672 | 54.6031 | 3 | http://en.wikipedia.org/wiki/Yas_Marina_Circuit | . &vellip;&vellip; | &vellip; | &vellip; | &vellip; | &vellip; | &vellip; | . first(df_results, 5) #show first 5 . 5 rows × 18 columns (omitted printing of 10 columns) . resultIdraceIddriverIdconstructorIdnumbergridpositionpositionText . Int64Int64Int64Int64String3Int64String3String3 . 11 | 18 | 1 | 1 | 22 | 1 | 1 | 1 | . 22 | 18 | 2 | 2 | 3 | 5 | 2 | 2 | . 33 | 18 | 3 | 3 | 7 | 7 | 3 | 3 | . 44 | 18 | 4 | 4 | 5 | 11 | 4 | 4 | . 55 | 18 | 5 | 1 | 23 | 3 | 5 | 5 | . df_results |&gt; describe . 18 rows × 7 columns . variablemeanminmedianmaxnmissingeltype . SymbolUnion…AnyUnion…AnyInt64DataType . 1resultId | 12731.3 | 1 | 12730.5 | 25465 | 0 | Int64 | . 2raceId | 523.144 | 1 | 507.0 | 1076 | 0 | Int64 | . 3driverId | 254.98 | 1 | 160.0 | 855 | 0 | Int64 | . 4constructorId | 47.9288 | 1 | 25.0 | 214 | 0 | Int64 | . 5number | | 0 | | N | 0 | String3 | . 6grid | 11.1959 | 0 | 11.0 | 34 | 0 | Int64 | . 7position | | 1 | | N | 0 | String3 | . 8positionText | | 1 | | W | 0 | String3 | . 9positionOrder | 12.9115 | 1 | 12.0 | 39 | 0 | Int64 | . 10points | 1.82903 | 0.0 | 0.0 | 50.0 | 0 | Float64 | . 11laps | 45.8567 | 0 | 52.0 | 200 | 0 | Int64 | . 12time | | + 1:06.7 | | N | 0 | String15 | . 13milliseconds | | 10014100 | | N | 0 | String15 | . 14fastestLap | | 10 | | N | 0 | String3 | . 15rank | | 0 | | N | 0 | String3 | . 16fastestLapTime | | 0:55.404 | | N | 0 | String15 | . 17fastestLapSpeed | | 100.615 | | N | 0 | String7 | . 18statusId | 17.6454 | 1 | 11.0 | 139 | 0 | Int64 | . first(df_races, 5) #show first 5 . 5 rows × 8 columns . raceIdyearroundcircuitIdnamedatetimeurl . Int64Int64Int64Int64String31String15String15String . 11 | 2009 | 1 | 1 | Australian Grand Prix | 29/03/09 | 6:00:00 | http://en.wikipedia.org/wiki/2009_Australian_Grand_Prix | . 22 | 2009 | 2 | 2 | Malaysian Grand Prix | 05/04/09 | 9:00:00 | http://en.wikipedia.org/wiki/2009_Malaysian_Grand_Prix | . 33 | 2009 | 3 | 17 | Chinese Grand Prix | 19/04/09 | 7:00:00 | http://en.wikipedia.org/wiki/2009_Chinese_Grand_Prix | . 44 | 2009 | 4 | 3 | Bahrain Grand Prix | 26/04/09 | 12:00:00 | http://en.wikipedia.org/wiki/2009_Bahrain_Grand_Prix | . 55 | 2009 | 5 | 4 | Spanish Grand Prix | 10/05/09 | 12:00:00 | http://en.wikipedia.org/wiki/2009_Spanish_Grand_Prix | . df_races |&gt; describe . 8 rows × 7 columns (omitted printing of 3 columns) . variablemeanminmedian . SymbolUnion…AnyUnion… . 1raceId | 542.02 | 1 | 540.0 | . 2year | 1991.39 | 1950 | 1993.0 | . 3round | 8.43281 | 1 | 8.0 | . 4circuitId | 22.405 | 1 | 18.0 | . 5name | | 70th Anniversary Grand Prix | | . 6date | | 01/01/65 | | . 7time | | 10:10:00 | | . 8url | | http://en.wikipedia.org/wiki/1950_Belgian_Grand_Prix | | . first(df_constructors, 5) #show first 5 . 5 rows × 5 columns . constructorIdconstructorRefnamenationalityurl . Int64String31String31String15String . 11 | mclaren | McLaren | British | http://en.wikipedia.org/wiki/McLaren | . 22 | bmw_sauber | BMW Sauber | German | http://en.wikipedia.org/wiki/BMW_Sauber | . 33 | williams | Williams | British | http://en.wikipedia.org/wiki/Williams_Grand_Prix_Engineering | . 44 | renault | Renault | French | http://en.wikipedia.org/wiki/Renault_in_Formula_One | . 55 | toro_rosso | Toro Rosso | Italian | http://en.wikipedia.org/wiki/Scuderia_Toro_Rosso | . df_constructors |&gt; describe . 5 rows × 7 columns (omitted printing of 2 columns) . variablemeanminmedianmax . SymbolUnion…AnyUnion…Any . 1constructorId | 107.038 | 1 | 107.0 | 214 | . 2constructorRef | | adams | | zakspeed | . 3name | | AFM | | Zakspeed | . 4nationality | | American | | Swiss | . 5url | | http://en.wikipedia.org/wiki/A.J._Watson | | http://en.wikipedia.org/wiki/Zakspeed | . Joining data from different sources . df_resul = innerjoin(df_results, df_drivers, on = :driverId, makeunique=true); . df_resulcons = innerjoin(df_resul, df_races, on = :raceId, makeunique=true); . df_resulrac = innerjoin(df_resulcons, df_constructors, on = :constructorId, makeunique=true); . first(df_resul, 5) . 5 rows × 26 columns (omitted printing of 18 columns) . resultIdraceIddriverIdconstructorIdnumbergridpositionpositionText . Int64Int64Int64Int64String3Int64String3String3 . 11 | 18 | 1 | 1 | 22 | 1 | 1 | 1 | . 22 | 18 | 2 | 2 | 3 | 5 | 2 | 2 | . 33 | 18 | 3 | 3 | 7 | 7 | 3 | 3 | . 44 | 18 | 4 | 4 | 5 | 11 | 4 | 4 | . 55 | 18 | 5 | 1 | 23 | 3 | 5 | 5 | . for nam in names(df_resul) println(nam) end . resultId raceId driverId constructorId number grid position positionText positionOrder points laps time milliseconds fastestLap rank fastestLapTime fastestLapSpeed statusId driverRef number_1 code forename surname dob nationality url . Plot Map with Circuits . lat = df_circuits[!,&quot;lat&quot;]; lng = df_circuits[!,&quot;lng&quot;]; . gr() plot(shp_countries, alpha=0.21) scatter!(lng, lat, ms = 3, c = &quot;red&quot;, type=&quot;heatmap&quot;) xlabel!(&quot;latitude&quot;) ylabel!(&quot;longitude&quot;) title!(&quot;Formula One Circuits&quot;) . Drivers with more Wins . wins(pos) = pos == &quot;1&quot; df_numWins = filter(:position =&gt; wins, df_resul) . 1,063 rows × 26 columns (omitted printing of 18 columns) . resultIdraceIddriverIdconstructorIdnumbergridpositionpositionText . Int64Int64Int64Int64String3Int64String3String3 . 11 | 18 | 1 | 1 | 22 | 1 | 1 | 1 | . 223 | 19 | 8 | 6 | 1 | 2 | 1 | 1 | . 345 | 20 | 13 | 6 | 2 | 2 | 1 | 1 | . 467 | 21 | 8 | 6 | 1 | 1 | 1 | 1 | . 589 | 22 | 13 | 6 | 2 | 1 | 1 | 1 | . 6109 | 23 | 1 | 1 | 22 | 3 | 1 | 1 | . 7129 | 24 | 9 | 2 | 4 | 2 | 1 | 1 | . 8149 | 25 | 13 | 6 | 2 | 2 | 1 | 1 | . 9169 | 26 | 1 | 1 | 22 | 4 | 1 | 1 | . 10189 | 27 | 1 | 1 | 22 | 1 | 1 | 1 | . 11209 | 28 | 5 | 1 | 23 | 2 | 1 | 1 | . 12229 | 29 | 13 | 6 | 2 | 1 | 1 | 1 | . 13249 | 30 | 13 | 6 | 2 | 2 | 1 | 1 | . 14269 | 31 | 20 | 5 | 15 | 1 | 1 | 1 | . 15289 | 32 | 4 | 4 | 5 | 15 | 1 | 1 | . 16309 | 33 | 4 | 4 | 5 | 4 | 1 | 1 | . 17329 | 34 | 1 | 1 | 22 | 1 | 1 | 1 | . 18349 | 35 | 13 | 6 | 2 | 1 | 1 | 1 | . 19369 | 36 | 8 | 6 | 6 | 1 | 1 | 1 | . 20391 | 37 | 4 | 1 | 1 | 2 | 1 | 1 | . 21413 | 38 | 13 | 6 | 5 | 1 | 1 | 1 | . 22435 | 39 | 13 | 6 | 5 | 1 | 1 | 1 | . 23457 | 40 | 4 | 1 | 1 | 1 | 1 | 1 | . 24479 | 41 | 1 | 1 | 2 | 1 | 1 | 1 | . &vellip;&vellip; | &vellip; | &vellip; | &vellip; | &vellip; | &vellip; | &vellip; | &vellip; | . first(df_numWins,5) . 5 rows × 26 columns (omitted printing of 18 columns) . resultIdraceIddriverIdconstructorIdnumbergridpositionpositionText . Int64Int64Int64Int64String3Int64String3String3 . 11 | 18 | 1 | 1 | 22 | 1 | 1 | 1 | . 223 | 19 | 8 | 6 | 1 | 2 | 1 | 1 | . 345 | 20 | 13 | 6 | 2 | 2 | 1 | 1 | . 467 | 21 | 8 | 6 | 1 | 1 | 1 | 1 | . 589 | 22 | 13 | 6 | 2 | 1 | 1 | 1 | . df_numWins |&gt; names; . gdf = groupby(df_numWins, :driverId); . dfw = combine(gdf, nrow =&gt; :WinsCount); . df_drivers_winners = innerjoin(dfw, df_drivers, on = :driverId, makeunique=true); . sort!(df_drivers_winners, :WinsCount, rev=true); . bar( df_drivers_winners[:,:driverRef], df_drivers_winners[:,:WinsCount], rotation=45, xticks = :all,size=(1200,400) ) . Very hard to see with this long tail, so we will limit to top 25 drivers . df_drivers_winners25 = first(df_drivers_winners,25); #show first 25 . plotlyjs() bar( df_drivers_winners25[:,:driverRef], df_drivers_winners25[:,:WinsCount], rotation=45, xticks = :all,size=(800,400), title=&quot;Top 25 Formula One Drivers with the Most Wins&quot;) . Constructors ChampionShip by Season . df_numWins = filter(:year =&gt; year -&gt; year == 2013, df_resulrac); . gdf = groupby(df_numWins, :constructorRef); . dfc = combine(gdf, :points =&gt; sum) . 11 rows × 2 columns . constructorRefpoints_sum . String31Float64 . 1lotus_f1 | 315.0 | . 2ferrari | 354.0 | . 3red_bull | 596.0 | . 4mercedes | 360.0 | . 5force_india | 77.0 | . 6mclaren | 122.0 | . 7toro_rosso | 33.0 | . 8sauber | 57.0 | . 9williams | 5.0 | . 10marussia | 0.0 | . 11caterham | 0.0 | . sort!(dfc, :points_sum, rev=true); . plotlyjs() bar( dfc[:,:constructorRef], dfc[:,:points_sum], rotation=45, xticks = :all,size=(800,400), title=&quot;Constructor Championship Ranking&quot;) . construcRanking(y) = filter(:year =&gt; year -&gt; year == y, df_resulrac); . construcRanking(2020) . 340 rows × 37 columns (omitted printing of 29 columns) . resultIdraceIddriverIdconstructorIdnumbergridpositionpositionText . Int64Int64Int64Int64String3Int64String3String3 . 124626 | 1031 | 822 | 131 | 77 | 1 | 1 | 1 | . 224627 | 1031 | 844 | 6 | 16 | 7 | 2 | 2 | . 324628 | 1031 | 846 | 1 | 4 | 3 | 3 | 3 | . 424629 | 1031 | 1 | 131 | 44 | 5 | 4 | 4 | . 524630 | 1031 | 832 | 1 | 55 | 8 | 5 | 5 | . 624631 | 1031 | 815 | 211 | 11 | 6 | 6 | 6 | . 724632 | 1031 | 842 | 213 | 10 | 12 | 7 | 7 | . 824633 | 1031 | 839 | 4 | 31 | 14 | 8 | 8 | . 924634 | 1031 | 841 | 51 | 99 | 18 | 9 | 9 | . 1024635 | 1031 | 20 | 6 | 5 | 11 | 10 | 10 | . 1124636 | 1031 | 849 | 3 | 6 | 20 | 11 | 11 | . 1224637 | 1031 | 826 | 213 | 26 | 13 | 12 | 12 | . 1324638 | 1031 | 848 | 9 | 23 | 4 | 13 | 13 | . 1424639 | 1031 | 8 | 51 | 7 | 19 | N | R | . 1524640 | 1031 | 847 | 3 | 63 | 17 | N | R | . 1624641 | 1031 | 154 | 210 | 8 | 15 | N | R | . 1724642 | 1031 | 825 | 210 | 20 | 16 | N | R | . 1824643 | 1031 | 840 | 211 | 18 | 9 | N | R | . 1924644 | 1031 | 817 | 4 | 3 | 10 | N | R | . 2024645 | 1031 | 830 | 9 | 33 | 2 | N | R | . 2124646 | 1032 | 1 | 131 | 44 | 1 | 1 | 1 | . 2224647 | 1032 | 822 | 131 | 77 | 4 | 2 | 2 | . 2324648 | 1032 | 830 | 9 | 33 | 2 | 3 | 3 | . 2424649 | 1032 | 848 | 9 | 23 | 6 | 4 | 4 | . &vellip;&vellip; | &vellip; | &vellip; | &vellip; | &vellip; | &vellip; | &vellip; | &vellip; | . Evolution of Constructors . One thing I would like to see is the evolution of constructors over the years: . gdfy = groupby(df_resulrac, [:constructorRef, :year]); . dfcy = combine(gdfy, :points =&gt; sum) . 1,091 rows × 3 columns . constructorRefyearpoints_sum . String31Int64Float64 . 1mclaren | 2008 | 151.0 | . 2bmw_sauber | 2008 | 135.0 | . 3williams | 2008 | 26.0 | . 4renault | 2008 | 80.0 | . 5toro_rosso | 2008 | 39.0 | . 6ferrari | 2008 | 172.0 | . 7toyota | 2008 | 56.0 | . 8super_aguri | 2008 | 0.0 | . 9red_bull | 2008 | 29.0 | . 10force_india | 2008 | 0.0 | . 11honda | 2008 | 14.0 | . 12ferrari | 2007 | 204.0 | . 13mclaren | 2007 | 218.0 | . 14bmw_sauber | 2007 | 101.0 | . 15renault | 2007 | 51.0 | . 16williams | 2007 | 33.0 | . 17toyota | 2007 | 13.0 | . 18honda | 2007 | 6.0 | . 19super_aguri | 2007 | 4.0 | . 20red_bull | 2007 | 24.0 | . 21toro_rosso | 2007 | 8.0 | . 22spyker | 2007 | 1.0 | . 23renault | 2006 | 206.0 | . 24ferrari | 2006 | 201.0 | . &vellip;&vellip; | &vellip; | &vellip; | . filter(:year =&gt; year -&gt; year == 2008, dfcy) . 11 rows × 3 columns . constructorRefyearpoints_sum . String31Int64Float64 . 1mclaren | 2008 | 151.0 | . 2bmw_sauber | 2008 | 135.0 | . 3williams | 2008 | 26.0 | . 4renault | 2008 | 80.0 | . 5toro_rosso | 2008 | 39.0 | . 6ferrari | 2008 | 172.0 | . 7toyota | 2008 | 56.0 | . 8super_aguri | 2008 | 0.0 | . 9red_bull | 2008 | 29.0 | . 10force_india | 2008 | 0.0 | . 11honda | 2008 | 14.0 | . f(ref, yr) = ref == &quot;mclaren&quot; &amp;&amp; yr == 2008; . filter([:constructorRef, :year] =&gt; f, dfcy) . 1 rows × 3 columns . constructorRefyearpoints_sum . String31Int64Float64 . 1mclaren | 2008 | 151.0 | . filter([:constructorRef, :year] =&gt; f, dfcy) . 1 rows × 3 columns . constructorRefyearpoints_sum . String31Int64Float64 . 1mclaren | 2008 | 151.0 | . getConstructPointsYr(constrRef, yr) = filter([:constructorRef, :year] =&gt; (x,y) -&gt; x == constrRef &amp;&amp; y &gt;= yr, dfcy) . getConstructPointsYr (generic function with 1 method) . mc = getConstructPointsYr(&quot;mclaren&quot;, 2008); ferr = getConstructPointsYr(&quot;ferrari&quot;, 2008); williams = getConstructPointsYr(&quot;williams&quot;, 2008); mercedes = getConstructPointsYr(&quot;mercedes&quot;, 2008); redbull = getConstructPointsYr(&quot;red_bull&quot;, 2008); . plot(ferr[:, :year], ferr[:, :points_sum], marker=:o, color=&quot;red&quot;, title=&quot;Constructors Points since 2008&quot;, grid=true, size=(800,400), rotation=45, xticks = 2008:2022, legend = true, label=&quot;Ferrari&quot;) plot!(mc[:, :year], mc[:, :points_sum], marker=:^, color=&quot;blue&quot;, label = &quot;McLaren&quot;) plot!(williams[:, :year], williams[:, :points_sum], marker=:diamond, color=&quot;green&quot;, label = &quot;Williams&quot;) plot!(mercedes[:, :year], mercedes[:, :points_sum], marker=:square, color=&quot;orange&quot;, label = &quot;Mercedes&quot;) plot!(redbull[:, :year], redbull[:, :points_sum], marker=:cross, color=&quot;purple&quot;, label = &quot;Red Bull&quot;) . That is it for now. Next post we will analyse more driver and lap data. .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/datascience/formula_one/2022/05/08/FormulaOne_Part1.html",
            "relUrl": "/jupyter/datascience/formula_one/2022/05/08/FormulaOne_Part1.html",
            "date": " • May 8, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Signal Processing with Julia Language- Part 5",
            "content": "Sinusoidal Sequence . Defined as: . $$x(n) = sin(ω.n + φ), forall n in mathbb{ N}$$ . # Load dependencies using MySignalProcessing using Plots . . # with 100 samples every 2 full 2pi cycles s = 1.0 * sinseq(0,100, 0.125); . plot(s.n, s.A, line=:stem, title=&quot;Sinusoidal signal&quot;, marker = :o, color = :blue) . The same thing can be accomplished with the canonical form constructor:$$x[n]=sin( frac{M}{N} 2 pi n)$$ . #N = 100 s = 1.0 * sinseqmn(0,100, 2, 100); . plot(s.n, s.A, line=:stem, title=&quot;Sinusoidal signal&quot;, marker = :o, color = :black) . Signal Processing: . Take the above signal and &quot;rectify&quot; it by flipping negative half-cycles to positive. . # then going to take these negative cycles and flip polarity to positive cycles # and then add back to the original signal. # this will result in a signal with only positive cycles M= stepseq(0,25); . m1 = M |&gt; sigshift(25); m2 = M |&gt; sigshift(75); . p1 = plot(m1.n, m1.A, line=:stem, title=&quot;Step sequence&quot;, marker = :o, color = :red, xlims=(0,100)) p2 = plot(m2.n, m2.A, line=:stem, title=&quot;Step sequence&quot;, marker = :o, color = :red, xlims=(0,100)) plot(p1, p2, layout=(2,1)) . mask = m1+m2 . signal(Real[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 … 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], Real[25, 26, 27, 28, 29, 30, 31, 32, 33, 34 … 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) . s2 = s*mask . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … -0.9048270524660192, -0.8443279255020152, -0.7705132427757886, -0.6845471059286885, -0.587785252292472, -0.48175367410171477, -0.3681245526846781, -0.24868988716485388, -0.125333233564304, 1.2864981197413093e-15], Real[0, 1, 2, 3, 4, 5, 6, 7, 8, 9 … 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) . plot(s2.n, s2.A, line=:stem, title=&quot;Sinusoidal signal&quot;, marker = :o, color = :blue) . s3 = s + (-1*s*mask) + (-1*s*mask); . plot(s3.n, s3.A, line=:stem, title=&quot;Sinusoidal signal&quot;, marker = :o, color = :blue) . s3 = s + (-1*s*mask) + (-1*s*mask); s3 = s + (-2s*mask); . plot(s3.n, s3.A, line=:stem, title=&quot;Sinusoidal signal&quot;, marker = :o, color = :blue) . Decomposition and Synthesis . There are several important results in Discrete signal theory. One of them is the decomposition of signals into Even and Odd signals. . We define Even signals if : . $$Xₑ(-n) = Xₑ(n)$$ . Similarly , we define Odd signals if : . $$Xₒ(-n) = Xₒ(n)$$ . Any artibrary real-valued signal can be decomposed into Even and Odd signals: . $$x(n) = xₑ(n) + xₒ(n)$$ . where even and odd signals are given by: . $$xₑ(n) = frac{1}{2}[x(n) + x(-n)]$$ . $$Xₒ(n) = frac{1}{2}[x(n) - x(-n)]$$ . With our building block function we have already defined, we can now define the synthesis of the signal. . Let $$x(n) = u(n) -u(n-10)$$ , . Decompose it into Even and Odd signals: . x = stepseq(-30, 30) + (-1*stepseq(-20,20)|&gt; sigshift(10)) . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Real[-30, -29, -28, -27, -26, -25, -24, -23, -22, -21 … 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]) . plot(x.n, x.A, line=:stem, title=&quot;unit signal&quot;, marker = :o, color = :blue) . Xₑ = (1/2)* (x + (x |&gt; sigfold)); # pls see fold function definition . Xₒ = (1/2)* (x + -1*(x |&gt; sigfold)); # pls see fold function definition . p1 = plot(x.n, x.A, line=:stem, title=&quot;unit signal&quot;, marker = :o, color = :blue, label = &quot;x&quot;) p2 = plot(Xₑ.n, Xₑ.A, line=:stem, title=&quot;Even Part&quot;, marker = :o, color = :red, label = &quot;Xₑ&quot;) p3 = plot(Xₒ.n, Xₒ.A, line=:stem, title=&quot;Odd Part&quot;, marker = :o, color = :green, label = &quot;Xₒ&quot;) plot(p1, p2, p3, layout=(3,1)) .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/signalprocessing/2022/05/07/SignalProcessingPart5.html",
            "relUrl": "/jupyter/signalprocessing/2022/05/07/SignalProcessingPart5.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Signal Processing with Julia Language- Part 4",
            "content": "Background Information . in previous posts we have seen how to create a signal with a given amplitude and sample range, as well as presented some basic functions for signal processing. Now we are ready to put these functions to good use. . For more information, pls see the following links: . For background information, pls see Signal Processing with Julia Language- Part I . In part 1 we discussed how to represent a signal, and constructor functions using my signal package in Julia. . My signal processing package can be found at MySignalProcessing.jl . # Load dependencies using MySignalProcessing using Plots . . Plot sequence as defined by the following equation: . $$x_1(n) = 2x(n-5) - 3x(n+4)$$ . given the signal $$x(n) = {1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1 } text{ , where } n= {-2, -1 , 0 , 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }$$ . The first part is obtained by shifting x(n) by +5 and the second part by shifting x(n) by -4. | . 1. Lets create the given signal first: . x = [1,2,3,4,5,6,7,6,5,4,3,2,1]; #amplitude vector n = [-2,-1,0,1,2,3,4,5,6,7,8,9,10]; #sample position vector s = signal(x,n) # create signal from the two vectors . signal(Real[1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1], Real[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) . 2. We can break it down the process in parts , just to visualize better: . # Original signal p1 = plot(s.n, s.A, line =:stem, marker=:o, color=:blue, label = &quot;s&quot;, ylims = (-10,15), xlims=(-10,20), framestyle = :origin,xtick=-10:20,ytick=-10:15) . . x₂ = 2.0 * ( s |&gt; sigshift(5) ) ; . plot(x₂.n, x₂.A, line =:stem, marker=:o, color=:red, label = &quot;x₂&quot;, ylims = (-10,15), xlims=(-10,20), framestyle = :origin, xtick=-10:20, ytick=-10:15) . . x₃ = -3.0 * ( s |&gt; sigshift(-4) ) . signal(Real[-3.0, -6.0, -9.0, -12.0, -15.0, -18.0, -21.0, -18.0, -15.0, -12.0, -9.0, -6.0, -3.0], Real[-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6]) . plot(x₃.n, x₃.A, line =:stem, marker=:o, color=:green, label = &quot;x₃&quot;, ylims = (-25,15), xlims=(-10,20), framestyle = :origin, xtick=-10:20, ytick=-25:15) . 3. Add the two signals x&#8322; and x&#8323; together: . x₁ = x₂ + x₃ . signal(Real[-3.0, -6.0, -9.0, -12.0, -15.0, -18.0, -21.0, -18.0, -15.0, -10.0 … 5.0, 10.0, 12.0, 14.0, 12.0, 10.0, 8.0, 6.0, 4.0, 2.0], Real[-6, -5, -4, -3, -2, -1, 0, 1, 2, 3 … 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) . plot(x₁.n, x₁.A, line =:stem, marker=:o, color=:black, label = &quot;x₁&quot;, ylims = (-25,15), xlims=(-10,20), framestyle = :origin, xtick=-10:20, ytick=-25:15) . . 4. Off course , we could have just written everything at once, just like the theory: . x₁ = 2.0 * ( s |&gt; sigshift(5) ) + (-3.0) * ( s |&gt; sigshift(-4) ) . x₁ = 2.0 * ( s |&gt; sigshift(5) ) + (-3.0) * ( s |&gt; sigshift(-4) ) . signal(Real[-3.0, -6.0, -9.0, -12.0, -15.0, -18.0, -21.0, -18.0, -15.0, -10.0 … 5.0, 10.0, 12.0, 14.0, 12.0, 10.0, 8.0, 6.0, 4.0, 2.0], Real[-6, -5, -4, -3, -2, -1, 0, 1, 2, 3 … 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) . p1 = plot(s.n, s.A, line =:stem, marker=:o, color=:blue, label = &quot;s&quot;, ylims = (-10,15), xlims=(-10,20), framestyle = :origin, xtick=-10:20, ytick=-10:15); p2 = plot(x₁.n, x₁.A, line =:stem, marker=:o, color=:black, label = &quot;x₁&quot;, ylims = (-25,15), xlims=(-10,20), framestyle = :origin, xtick=-10:20, ytick=-25:15); plot(p1,p2, layout = (2,1), size = (800,800)) . .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/signalprocessing/2022/05/07/SignalProcessingPart4.html",
            "relUrl": "/jupyter/signalprocessing/2022/05/07/SignalProcessingPart4.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Signal Processing with Julia Language- Part 3",
            "content": "Background Information . Part 1 . For background information, pls see Signal Processing with Julia Language- Part I . In part 1 we discussed how to represent a signal, and constructor functions using my signal package in Julia. . My signal processing package can be found at MySignalProcessing.jl . Part 2 . Basic Functions Signal Processing with Julia Language- Part 2 . using MySignalProcessing using Plots . Signal add . We can add two signals together. However, we need to make sure that the signals have the same length. If sequences are of unequal lenghts or if the sample positions are different for equal-length sequences, the we cannot directly add. We have to first augment x1(n) and x2(n) , so that they have the same position vector n (and hence the same length). . Furtunally, the sigadd function does all that for us. . s1 = impseq(-10, 10); s2 = stepseq(-5, 15); . sigadd(s1, s2) . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], Real[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1 … 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) . p1 = plot(s1.n, s1.A, line =:stem, marker=:o) p2= plot(s2.n, s2.A, line =:stem, marker=:o) p3 = plot(sigadd(s1, s2).n, sigadd(s1, s2).A, line =:stem, marker=:o) plot(p1,p2,p3, layout=(3,1), xlims=(-10, 15)) . Julia language has a powerful multiple dispatch mechanism, which allows us to call a function based on the type of the arguments. Therefore, we can easily extend the Base.+ function to work with our signal package. This way, we can add two signals together : . signal1 + signal2 . s₃ = s1 + s2 #Base.+ Operator extended to work with our package . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], Real[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1 … 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) . p1 = plot(s1.n, s1.A, line =:stem, marker=:o) p2= plot(s2.n, s2.A, line =:stem, marker=:o) p3 = plot(s₃.n, s₃.A, line =:stem, marker=:o) plot(p1,p2,p3, layout=(3,1), xlims=(-10, 15)) . Signal Shift . Julia is known for the highly composable nature of its language. Meaning that functions can be composed of other functions and we can use the output of one function as the input of another. This leads to a very powerful tool for signal processing. Hopefully you are starting to see the elegance in which Julia is able to do this. . s = impseq(-10, 10); sshifted = s |&gt; sigshift(5) # |&gt; is the pipe operator, piping the signal through a function and shifting it by 5 samples . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Real[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4 … 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) . The same thing could also be written as: . sigshift(5) ∘ s # this is the same as the above, however, we compose from right to left . MySignalProcessing.var&#34;#1#2&#34;{Int64}(5) ∘ signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Real[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1 … 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) . p1 = plot(s.n, s.A, line =:stem, marker=:o) p2 = plot(sshifted.n, sshifted.A, line =:stem, marker=:o) fig3 = plot(p1,p2, layout=(1,2)) display(fig3) . Signal Multiply . s1 = stepseq(-10, 10) |&gt; sigshift(-5); s2 = signal(0.0, -15, 15); s3 = sigadd(s1,s2); . p1 = plot(s1.n, s1.A, line =:stem, marker=:o, xlims=(-15,15)) p2 = plot(s2.n, s2.A, line =:stem, marker=:o, xlims=(-15,15)) p3 = plot(s3.n, s3.A, line =:stem, marker=:o, xlims=(-15,15)) plot(p1,p2,p3, layout=(3,1)) . s4 = signal(1.0, -15, 15); s5 = signal(0.0, -15, 15); s5.A = rand.().*s4.A; . p5 = plot(s5.n, s5.A, line =:stem, marker=:o, xlims=(-15,15), ylims=(0,1)) . Signal Multiplication: Function to multiply two signal s1 and s2. pls note that the signals must have the same length. If sequences are of unequal lenghts or if the sample positions are different for equal-length sequences, the we cannot directly add. We have to first augment x1(n) and x2(n) , so that they have the same position vector n (and hence the same length). . The amplitude of the resulting signal is the product of the amplitudes of the two signals, element-wise. . s6 = sigmult(s5, s3) . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Real[-15, -14, -13, -12, -11, -10, -9, -8, -7, -6 … 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) . p1 = plot(s3.n, s3.A, line =:stem, marker=:o, xlims=(-15,15)) p2 = plot(s5.n, s5.A, line =:stem, marker=:o, xlims=(-15,15)) p3 = plot(s6.n, s6.A, line =:stem, marker=:o, xlims=(-15,15)) plot(p1,p2,p3, layout=(3,1)) . Just like the signal add, we have also extended Base.* to work with our signal package: . s7 = s5 * s3 . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 … 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Real[-15, -14, -13, -12, -11, -10, -9, -8, -7, -6 … 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) . p1 = plot(s3.n, s3.A, line =:stem, marker=:o, xlims=(-15,15), color=:blue) p2 = plot(s5.n, s5.A, line =:stem, marker=:o, xlims=(-15,15), color=:black) p3 = plot(s7.n, s7.A, line =:stem, marker=:o, xlims=(-15,15), color=:red) plot(p1,p2,p3, layout=(3,1)) . With some very basic functions, we can already do some pretty interesting things. Next post, we will really build on these functions to get into applications and see how they can be used in signal processing. .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/signalprocessing/2022/05/07/SignalProcessingPart3.html",
            "relUrl": "/jupyter/signalprocessing/2022/05/07/SignalProcessingPart3.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Convolution with Julia Language",
            "content": "Convolution . In DSP, Convolution is an important operation and has many other uses. . Let&#39;s understand how a Linear system changes an input signal into an output signal. First, the input signal can be decomposed into a set of impulses, each of which can be viewed as a scaled and shifted delta function. Second, the output resulting from each impulse is a scaled and shifted version of the impulse response. Third, the overall output signal can be found by adding these scaled and shifted impulse responses. In other words, if we know a system&#39;s impulse response, then we can calculate what the output will be for any possible input signal. This means we know everything about the system. There is nothing more that can be learned about a linear system&#39;s characteristics. . Convolution is a formal mathematical operation, just as multiplication, addition, and integration. Addition takes two numbers and produces a third number, while convolution takes two signals and produces a third signal. Convolution is used in the mathematics of many fields, such as probability and statistics. In linear systems, convolution is used to describe the relationship between three signals of interest: the input signal, the impulse response, and the output signal. . Just as addition is represented by the plus, +, and multiplication by the cross, ×, convolution is represented by the star, *. It is unfortunate that most programming languages also use the star to indicate multiplication. This is also true for the Julia Language. . An input signal, x[n], enters a linear system with an impulse response, h[n], resulting in an output signal, y[n]. . In equation form: . $$y[n] = x[n] * h[n]$$ . In most DSP applications, the input signal is hundreds, thousands, or even millions of samples in length. The impulse response is usually much shorter, say, a few points to a few hundred points. . The mathematics behind convolution doesn&#39;t restrict how long these signals are. It does, however, specify the length of the output signal. The length of the output signal is equal to the length of the input signal, plus the length of the impulse response, minus one. . Now we come to the detailed mathematics of convolution. As used in Digital Signal Processing, convolution can be understood in two separate ways. The first looks at convolution from the viewpoint of the input signal. This involves analyzing how each sample in the input signal contributes to many points in the output signal. The second way looks at convolution from the viewpoint of the output signal. This examines how each sample in the output signal has received information from many points in the input signal. . Keep in mind that these two perspectives are different ways of thinking about the same mathematical operation. . using MySignalProcessing using Plots . Building our Signals . Julia language is known to be a highly composable Language. . This means that higher order functions are made of other functions. This is a very powerful tool in DSP. . We build our signals by performing a series of operations on the signal, as the following example shows. . X = stepseq(-5,50) + (-1) * (stepseq(0,40) |&gt; sigshift(10)) . Let the rectangular pulse: . $$x(n) = u(n) - u(n - 10)$$ . be an input to an LTI System with Impulse Response: . $$h(n) = (0.9)^n u(n)$$ . Input Signal . x = stepseq(-5,50) + (-1) * (stepseq(0,40) |&gt; sigshift(10)) . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0 … 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Real[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4 … 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]) . plot(x.n, X.A, line =:stem, marker=:o, title = &quot;Input Signal&quot;) . Impulse Response . h = (signal(0.0, -5,50) + realexp(0.9, 0, 50)) . signal(Real[0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.9, 0.81, 0.7290000000000001, 0.6561 … 0.013302794647291146, 0.011972515182562033, 0.01077526366430583, 0.009697737297875247, 0.008727963568087723, 0.00785516721127895, 0.007069650490151055, 0.00636268544113595, 0.005726416897022355, 0.00515377520732012], Real[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4 … 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]) . plot(h.n, h.A, line =:stem, marker=:o, title = &quot;Impulse Response&quot;) . Convolution . Now that we have our input and Impulse Response signals, we can just call the convolution function. . y = conv(x,h) . y = conv(x, h) . signal(Real[-1.2688263138573217e-16, -6.344131569286608e-16, -7.61295788314393e-16, -2.5376526277146434e-16, 1.2688263138573217e-16, -5.075305255429287e-16, -5.075305255429287e-16, -2.5376526277146434e-16, 0.0, -5.075305255429287e-16 … -5.075305255429287e-16, 0.0, -2.5376526277146434e-16, -2.5376526277146434e-16, 2.5376526277146434e-16, 0.0, 5.075305255429287e-16, 0.0, -1.2688263138573217e-16, -5.075305255429287e-16], Real[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1 … 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) . plot(y.n, y.A, line =:stem, marker=:o, title = &quot;Output Signal&quot;) . Another Example . If we have the signals in Array form, we can create them directly: . x = ([3.0, 11.0, 7.0, 0.0, -1.0, 4.0, 2.0], collect(-3:3)) . ([3.0, 11.0, 7.0, 0.0, -1.0, 4.0, 2.0], [-3, -2, -1, 0, 1, 2, 3]) . x = signal(x...) . signal(Real[3.0, 11.0, 7.0, 0.0, -1.0, 4.0, 2.0], Real[-3, -2, -1, 0, 1, 2, 3]) . plot(x.n, x.A, line =:stem, marker=:o, title = &quot;Input Signal&quot;) . h = ([2.0, 3.0, 0.0, -5.0, 2.0, 1.0], collect(-1:4)) . ([2.0, 3.0, 0.0, -5.0, 2.0, 1.0], [-1, 0, 1, 2, 3, 4]) . h = signal(h...) . signal(Real[2.0, 3.0, 0.0, -5.0, 2.0, 1.0], Real[-1, 0, 1, 2, 3, 4]) . plot(h.n, h.A, line =:stem, marker=:o, title = &quot;Impulse Response&quot;) . y = conv(x, h) . signal(Real[5.999999999999997, 31.0, 47.0, 6.0, -51.0, -4.9999999999999964, 41.0, 18.0, -22.0, -3.0, 8.0, 2.0000000000000018], Real[-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7]) . plot(y.n, y.A, line =:stem, marker=:o, title = &quot;Output Signal&quot;) . We could verify that Convolution Operation is commutative: . y = conv(h, x) . signal(Real[5.999999999999997, 31.0, 47.0, 6.0, -51.0, -4.9999999999999964, 41.0, 18.0, -22.0, -3.0, 8.0, 2.0000000000000018], Real[-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7]) . plot(y.n, y.A, line =:stem, marker=:o, title = &quot;Output Signal&quot;) .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/signalprocessing/2022/05/07/Convolution.html",
            "relUrl": "/jupyter/signalprocessing/2022/05/07/Convolution.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "Golden Ratio",
            "content": "Introduction . The golden ratio, also known as the divine proportion or phi, is a mathematical constant found in nature that has been used by artists and architects for centuries. It is said that the proportions of the golden ratio are aesthetically pleasing to the human eye, and can be found in everything from flowers to galaxies. In this blog post, we will explore Euclid&#39;s pentagon and how it is related to the golden ratio. . In order to construct the geometry of the pentagon, we will use the excellent luxor.jl package. . Golden Ratio - Euclid&#39;s Elements and the Pentagon . The discovery of the golden ratio is one that dates back to ancient Greece. It was first mentioned in works by Euclid, Ptolemy during their respective times who all had differing views on what it actually meant but were still able recognize its significance for mathematics. . The importance of the golden ratio is evident in many ancient cultures. In Greece, Euclid and his students were interested to figure out how best could constructoids like pentagons or icosahedrons since these shapes provide us with some insight into architectural designs such as temples where they had fivefold symmetry around their circular bases which led them down a path towards discovering this constant that still impacts mathematics today. . So we are going to show why this constant is important when constructing the pentagon. . The following code constructs the pentagon using the luxor.jl package: . #load dependancies using Luxor; using Base.MathConstants; using SymPy; using Images; . . url = &quot;https://upload.wikimedia.org/wikipedia/commons/c/ce/Scuola_di_atene_23.jpg&quot;; download(url, &quot;scuola.jpg&quot;);#download to local file . . euclid = load(&quot;scuola.jpg&quot;) . &quot;&quot;&quot; guidelines() Set axis guideline for orientation &quot;&quot;&quot; function guidelines() setdash(&quot;dot&quot;) background(&quot;antiquewhite&quot;); setcolor(&quot;darkblue&quot;); arrow(Point(-250,0),Point(250,0)) arrow(Point(0,-250),Point(0,250)) #circle with radious of 200 circle(Point(0,0),200, :stroke) #box 400 x 400 box(Point(0,0), 400, 400, :stroke) setdash(&quot;solid&quot;) end . . guidelines . @draw begin guidelines() setline(0.3); ngon(Point(0,0), 200, 5, -pi/2, action = :stroke) setdash(&quot;dot&quot;) end . #get polygon vertices coordinates . @draw begin fontsize(14) guidelines() setline(0.3); setdash(&quot;solid&quot;) ngon(Point(0,0), 200, 5, -pi/2, action = :stroke) a = ngon(Point(0,0), 200, 5, -pi/2, action = :stroke, vertices=true) setdash(&quot;solid&quot;) setline(0.5); l1 = line(a[3], a[5], :stroke) l2 = line(a[2], a[4], :stroke) f1,ip1 = intersectionlines(a[3], a[5], a[2], a[4]) circle(ip1, 3, :fill) label(&quot;C&quot;, :W, ip1) label(&quot;A&quot;, :W, a[3]) label(&quot;B&quot;, :W, a[5]) label(&quot;D&quot;, :W, a[2]) end . When examining figure above,if we draw two diagonals from the center of the pentagon, we can see that the two diagonals are equal in length, forming 3 isoceles triangles. These diagonals are $AB$ and $BD$. . Using elementary geometry, we can show that according to Euclid&#39;s definition, point $C$ divides the line $AB$ precisely in a Golden Ratio $ phi$. Furthermore, the ratio AB to AD is also equal to $ phi$. . This fact illustrates that the ability to construct a line divided in a Golden Ratio provides a simple means to construct a pentagon. For this reason, the ancient Greeks were interested in $ phi$. . Thru simple measurements of line segments of figure, we can derive the ratios in question and show inevocably the presence of the golden ratio in the pentagon. . C = ip1; A = a[3]; B = a[5]; . Point(-3.6739403974420595e-14, -200.0) . AB = dimension(A,B)[1]; AC = dimension(A,C)[1]; BC = dimension(B,C)[1]; . Ratio of Line $BC / AC$: . BC_AC = round(BC/AC, digits = 5) . 1.61803 . Ratio of Line $AB / BC$ . AB_BC = round(AB / BC; digits=5) . 1.61803 . BC_AC == AB_BC . true . φ . φ = 1.6180339887498... . Deriving the Value of $ phi$ . Lets look again at the line $AB$ and $AC$ from the figure above. . Let Line Segment $AC$ (shorter segment) be 1 unit long and the length of Line Segment $AB$ be $x$. . If the ratio of $x$ to 1 is the same as that of $x+1$ to $x$, then the line has been cut in a Golden Ratio $ phi$: . @syms x . (x,) . We can set up an equation to solve for the length x. The equation leads to a quadratic: . $ frac{x}{1} = frac{x+1}{x} implies x^2 - x -1 =0$ . eq = ((x / 1) ~ (x+1) / x); #setting up the equation in SymPy . sols = solve(eq, x) . $ left[ begin{array}{r} frac{1}{2} - frac{ sqrt{5}}{2} frac{1}{2} + frac{ sqrt{5}}{2} end{array} right]$ sols[2] # value of Phi . $ frac{1}{2} + frac{ sqrt{5}}{2}$ sols[2] |&gt; float . 1.618033988749894848204586834365638117720309179805762862135448622705260462818892 .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/math/2022/01/16/GoldenRatio.html",
            "relUrl": "/jupyter/math/2022/01/16/GoldenRatio.html",
            "date": " • Jan 16, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "Hyperledger- Challenges and Solutions",
            "content": "Introduction . Blockchain technology is one of the most exciting innovations to come out in recent years. . Blockchain technology has been applied as a digital ledger, where all transactions are recorded and shared among networks. A blockchain allows for every party on the network to have a copy of any given record with no risk that someone can alter it without being detected. . This new public blockchain ledger has been developed specifically for use by large enterprises who want to take advantage of its features but may not be able to afford the high initial cost or technical know-how required for building their own system from scratch. In this blog post, we will discuss what a public blockchain is and how it works so you can decide if your business should implement this innovative technology into your infrastructure! . The Hyperledger . is a non-profit foundation that aims to advance cross-industry blockchain technologies. late last year, they announced the release of their new open source public blockchain ledger called Sawtooth Lake. Sawtooth Lake is designed for businesses who want to take advantage of the benefits offered by blockchains but don’t want to build their own system from scratch. . This blockchain has designed a Corporate Business layer on top of the blockchain in order to make it more user-friendly for businesses to adopt. The CBDL is a permissioned blockchain that allows businesses to control the who, what, and when of transactions on the ledger. . The Hyperledger Sawtooth Lake public blockchain ledger has many features that make it an attractive option for businesses looking to implement a blockchain solution. For example, it provides modularity as it is expected that a cross-industry blockchain will be used in many business scenarios , so functions such as storage, policy, access controls and others should be modular. . Another important factor is privacy and confidentiality, as it is the utmost importance that transactions on the network are visible only to those allowed to view it. Many other factors such as Identity, scalability, deterministic transactions, auditability, portability are considered. . How Businesses can Benefit from the Hyperledger . from the new public blockchain ledger: . -The ledger provides a highly secure and trusted environment for businesses to conduct transactions. It helps eliminate fraud as all transactions are irreversible once they have been validated by consensus across network nodes. This eliminates any possibilities of reversing already confirmed blocks, which is one of the main benefits that come along with using blockchain technology. . This also minimizes or completely removes human error from transactional processes since it is executed automatically after pre-defined rules and conditions within smart contracts on the blockchain , this saves time and money spent on employees performing manual tasks such as reconciliation between two ledgers in different networks . Finally, there is no need to establish trust among partners because everything works autonomously through code. . Challenges . Of course, implementing a successful corporate Hyperledger can be a dauting task. The first challenge would be to convince your organization that the benefits of blockchain technology outweigh its disadvantages. . The biggest obstacle is often convincing management teams and boards of directors that there are real business use cases for Hyperledger within their organizations because it’s important to note blockchain is still in its infancy . This means many people don’t really understand what exactly this new type of ledger can do or how it works, so they naturally resist changes. Once you have a solid understanding on how Hyperledger will benefit your company , then the next step involves deciding which components from the stack need to be used by each department within an organization . Some companies may just opt for using smart contracts while others may not see much value until more advanced features such as data privacy and security is rock-solid. This is when a consulting company such as J&amp;J Engineering can help put together a solid business-case and requirements for successful implementation. . Conclusion . : Blockchain is a new technology that has the potential to disrupt and revolutionize how we manage our information, but it will take time for this world-changing technology to be adopted by all businesses. . If you are interested in learning more about blockchain or if you would like help setting up your own private blockchain then please get in touch with J&amp;J Engineering today! We offer both Hyperledger workshops as well as custom solutions development services . .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/blockchain/2022/01/09/Blockchainpost.html",
            "relUrl": "/blockchain/2022/01/09/Blockchainpost.html",
            "date": " • Jan 9, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "Signal Processing with Julia Language- Part 2",
            "content": "Background Information - Part 1 . For background information, pls see Signal Processing with Julia Language- Part I . In part 1 we discussed how to represent a signal, and constructor functions using my signal package in Julia. . My signal processing package can be found at MySignalProcessing.jl . using MySignalProcessing using Plots . Basic Signal Processing Functions . In part 2 we will discuss some basic signal processing functions and how to create them for further manipulation. . Unit impulse signal . This sequence is defined as: . $$ delta(n) = begin{cases} 1 &amp; text{ if } n = 0 0 &amp; text{otherwise} end{cases}$$ . s = impseq(-10, 10); #create imp. sequence, -10 to 10 fig1 = plot(s.n, s.A, line =:stem, marker=:o) . Unit Step Sequence . This sequence is defined as: . $$u(n) = begin{cases} 1 &amp; text{ if } n geq 0 0 &amp; text{otherwise} end{cases}$$ . s = stepseq(-5, 10); fig2 = plot(s.n, s.A, line =:stem, marker=:o) . sigrand Function - Generates a random signal . s1 = sigrand(-15,10); #create random signal, -15 to 10 plot(s1.n, s1.A, line=:stem, color=:red, marker=:o, xlims=(-15,10)) . Real-Valued Exponential Signal . This function is defined as: . $$r(a, n) = a^n$$ . s = realexp(1.1, -50, 50); plot(s.n, s.A, line =:stem, marker=:o) . s = realexp(0.9, -50, 50); plot(s.n, s.A, line =:stem, marker=:o) .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/signalprocessing/2021/12/31/SignalProcessingPart2.html",
            "relUrl": "/jupyter/signalprocessing/2021/12/31/SignalProcessingPart2.html",
            "date": " • Dec 31, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "CoinGecko API Wrapper in Julia Language - Part 1",
            "content": "Basic API Documentation and Installation Information . One of the most powerfull crypto API&#39;s out there. APIs are simple and easy to use, fully documented at the website. . (&quot;CoinGecko API&quot; is a trademark of CoinGecko) . API Information: . CoinGecko API . Julia API Wrapper Package information: . Pls check my package information at the website for code and documentation. . gjunqueira-sys / CoinGeckoAPI . Example Use: Get top 10 coins by Market Cap . # Load dependancies using CoinGeckoAPI; using Plots; . . # check API documentation for more information - we are interested in the /coins/markets function call for this example # https://www.coingecko.com/en/api/documentation # call the API, market cap in USD, optional arguments are: # order: &quot;market_cap_desc&quot; # per_page: 10 # page: 1 # We are getting only the top 10 market caps r = get_coins_markets(&quot;usd&quot;, &quot;order&quot; =&gt; &quot;market_cap_desc&quot;, &quot;per_page&quot; =&gt; &quot;10&quot;, &quot;page&quot; =&gt; &quot;1&quot;); . Now lets look at the output closer: . length(r) . 10 . r |&gt; length #or call the same function but with the pipe operator, my preference! . 10 . r |&gt; typeof # this is a vector output, with length 10 . JSON3.Array{JSON3.Object, Base.CodeUnits{UInt8, String}, Vector{UInt64}} . we can check the first element: . r[1] . JSON3.Object{Base.CodeUnits{UInt8, String}, SubArray{UInt64, 1, Vector{UInt64}, Tuple{UnitRange{Int64}}, true}} with 26 entries: :id =&gt; &#34;bitcoin&#34; :symbol =&gt; &#34;btc&#34; :name =&gt; &#34;Bitcoin&#34; :image =&gt; &#34;https://assets.coingecko.com/coins/imag… :current_price =&gt; 48141 :market_cap =&gt; 907941443592 :market_cap_rank =&gt; 1 :fully_diluted_valuation =&gt; 1008064470982 :total_volume =&gt; 28281205085 :high_24h =&gt; 48990 :low_24h =&gt; 46648 :price_change_24h =&gt; -848.983 :price_change_percentage_24h =&gt; -1.73296 :market_cap_change_24h =&gt; -1.88657e10 :market_cap_change_percentage_24h =&gt; -2.03556 :circulating_supply =&gt; 18914237 :total_supply =&gt; 21000000 :max_supply =&gt; 21000000 :ath =&gt; 69045 ⋮ =&gt; ⋮ . Now let us get all the keys and values pairs: . keys(r[1]) . KeySet for a JSON3.Object{Base.CodeUnits{UInt8, String}, SubArray{UInt64, 1, Vector{UInt64}, Tuple{UnitRange{Int64}}, true}} with 26 entries. Keys: :id :symbol :name :image :current_price :market_cap :market_cap_rank :fully_diluted_valuation :total_volume :high_24h :low_24h :price_change_24h :price_change_percentage_24h :market_cap_change_24h :market_cap_change_percentage_24h :circulating_supply :total_supply :max_supply :ath ⋮ . values(r[1]) . ValueIterator for a JSON3.Object{Base.CodeUnits{UInt8, String}, SubArray{UInt64, 1, Vector{UInt64}, Tuple{UnitRange{Int64}}, true}} with 26 entries. Values: &#34;bitcoin&#34; &#34;btc&#34; &#34;Bitcoin&#34; &#34;https://assets.coingecko.com/coins/images/1/large/bitcoin.png?1547033579&#34; 48141 907941443592 1 1008064470982 28281205085 48990 46648 -848.982844209088 -1.73296 -1.8865720467968506e10 -2.03556 18914237 21000000 21000000 69045 ⋮ . For this example, we are only interested in name and market cap. . We can use the following code to push names and values to vectors for plotting: . Vₙ = [];# name vector Mc = []; #value vector for i in 1:length(r) push!(Vₙ, r[i][&quot;id&quot;]); #get vector with names push!(Mc, r[i][&quot;market_cap&quot;]); #get vector with market caps end . bar(Vₙ, Mc, title = &quot;top 10 coins market cap&quot;, ylabel=&quot;Market cap&quot;, xrotation= 45 ) #plot market caps . That&#39;s it! .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/julialang/crypto/2021/12/29/BasicAPIBlogPart1.html",
            "relUrl": "/jupyter/julialang/crypto/2021/12/29/BasicAPIBlogPart1.html",
            "date": " • Dec 29, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "Symbolic Euler's Method",
            "content": "# load dependacies using MyCalculus using Plots using Symbolics . . Apply Euler&#39;s method for the following First-Order Differential Equation: . $fun(t, y) = y^2 -t$ . fun(t, y) = y^2 -t . fun (generic function with 1 method) . Definition of Euler&#39;s Method function: . $EulerMethod(f, x₀, y₀, step= 0.5, n=100.0)$ . Function to approximate solution to an ordinary differential equation using the Euler&#39;s Method. dy/dx = f(x, y) where y(x₀) = y₀ and x₀ = x₀. . Arguments . $f:$ function to approximate solution to, of the form f(x, y). This is the right hand side of the differential equation. . | $x₀:$ initial $x$ value condition | $y₀:$ initial $y$ value condition | $step:$ step size for the Euler&#39;s Method | $n:$ number of steps to take | . Returns . $x:$ array of x values | $y:$ array of y values | . x, y = EulerMethod(fun, -1.0, -0.5, 0.5, 5) . ([-1.0, -0.5, 0.0, 0.5, 1.0], [-0.5, 0.125, 0.3828125, 0.456085205078125, 0.31009206222370267]) . plot(x,y, ylim=(-0.5,0.5), xlim=(-1,1), framestyle = :, ylabel = &quot;y&quot;, xlabel = &quot;x&quot;) . We can also use Symbolics by passing Symbolics variables to the function: . This is a good way to &quot;peek&quot; into the inner workings of the Euler&#39;s Method and see what it&#39;s doing for every iteration. . It also showcases the power of Symbolics. Due to highly composable julia code, we can use Symbolics everywhere a number is expected. . @variables x₀, y₀, step #defines the symbollics variables t, y = EulerMethod(fun, x₀, y₀, step, 5) . (Num[x₀, step + x₀, x₀ + 2step, x₀ + 3step, x₀ + 4step], Num[y₀, y₀ + step*(y₀^2 - x₀), y₀ + step*(y₀^2 - x₀) + step*((y₀ + step*(y₀^2 - x₀))^2 - step - x₀), y₀ + step*(y₀^2 - x₀) + step*((y₀ + step*(y₀^2 - x₀))^2 - step - x₀) + step*((y₀ + step*(y₀^2 - x₀) + step*((y₀ + step*(y₀^2 - x₀))^2 - step - x₀))^2 - 2step - x₀), y₀ + step*(y₀^2 - x₀) + step*((y₀ + step*(y₀^2 - x₀))^2 - step - x₀) + step*((y₀ + step*(y₀^2 - x₀) + step*((y₀ + step*(y₀^2 - x₀))^2 - step - x₀))^2 - 2step - x₀) + step*((y₀ + step*(y₀^2 - x₀) + step*((y₀ + step*(y₀^2 - x₀))^2 - step - x₀) + step*((y₀ + step*(y₀^2 - x₀) + step*((y₀ + step*(y₀^2 - x₀))^2 - step - x₀))^2 - 2step - x₀))^2 - 3step - x₀)]) . t; . begin{equation} left[ begin{array}{c} x{_0} step + x{_0} x{_0} + 2 step x{_0} + 3 step x{_0} + 4 step end{array} right] end{equation} y; . $$ begin{equation} left[ begin{array}{c} y{_0} y{_0} + step left( - x{_0} + y{_0}^{2} right) y{_0} + step left( - x{_0} + y{_0}^{2} right) + step left( - step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) right)^{2} right) y{_0} + step left( - x{_0} + y{_0}^{2} right) + step left( - step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) right)^{2} right) + step left( - 2 step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) + step left( - step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) right)^{2} right) right)^{2} right) y{_0} + step left( - x{_0} + y{_0}^{2} right) + step left( - step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) right)^{2} right) + step left( - 2 step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) + step left( - step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) right)^{2} right) right)^{2} right) + step left( - 3 step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) + step left( - step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) right)^{2} right) + step left( - 2 step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) + step left( - step - x{_0} + left( y{_0} + step left( - x{_0} + y{_0}^{2} right) right)^{2} right) right)^{2} right) right)^{2} right) end{array} right] end{equation}$$ .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/math/calculus/symbolics/julialang/2021/12/28/EulersMethod.html",
            "relUrl": "/jupyter/math/calculus/symbolics/julialang/2021/12/28/EulersMethod.html",
            "date": " • Dec 28, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "Signal Processing with Julia Language- Part I",
            "content": "Installation . This notebook will make use of my package located at MySignalProcessing.jl. . For installation, please follow the instructions in the README.md file at my github repository. . Signal Constructors . In these examples, we deal with Discrete Signals only. Discrete Signal, are most often used in the context of digital communication and have many applications in various engineering fields. . A discrete signal is a sequence of samples, each of which is a value of a specific type. . The correct way to represent a discrete signal is to use two vectors: . x: the time vector of the signal (horizontal axis), or in the discete case, the vector of the indices of the samples (n) | y: the values of the signal (vertical axis), or its amplitude, at each of the samples (n). | . As such, I define a custom type, namely Signal, which is a structure that contains the two vectors above. . It has a .A fieldname, which is the amplitude of the signal and a .n fieldname, which is the sample vector. . mutable struct signal A::Vector{Real} #Amplitude of the signal n::Vector{Real} #horizontal axis (discrete) of signal (in samples) end . signal(A::Real, n::Int) Constructor . using MySignalProcessing using Plots . . s = signal(1.5, 10) # create a signal with amplitude 1.5 and number of samples 10, starting from sample 0 . signal(Real[1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5], Real[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) . We can now check the fieldnames of signal s: . s |&gt; typeof . signal . s |&gt; typeof |&gt; fieldnames . (:A, :n) . s.A |&gt; println . Real[1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5] . s.n |&gt; println . Real[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . plot(s.n, s.A, line= :stem, title = &quot;Signal&quot;, marker=:o, size=(400,300), ylabel=&quot;Amplitude&quot;, xlabel=&quot;Sample&quot;) . signal(A::Real, start::Int, stop::Int) Constructor . s1 = signal(π , -5,7) # create a signal with amplitude pi , starting from sample -5 and ending at sample 7 . signal(Real[3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793, 3.141592653589793], Real[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7]) . plot(s1.n, s1.A, line= :stem, title = &quot;Signal&quot;, marker=:o, size=(400,300), ylabel=&quot;Amplitude&quot;, xlabel=&quot;Sample&quot;) . signal(A::Vector, n::Vector) Constructor . With this constructor, we can buld a signal by passing two vectors to the function, one for the amplitude and one for the sample vector. . A = rand(4); n = [-1, 0, 1, 2]; s3 = signal(A, n); . plot(s3.n, s3.A, line= :stem, title = &quot;Signal&quot;, marker=:o, size=(400,300), ylabel=&quot;Amplitude&quot;, xlabel=&quot;Sample&quot;) . The signal type is the basic building block for various functions. Now you have a good understanding of the basic structure of a signal. .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/signalprocessing/2021/12/27/SignalProcessingPart1.html",
            "relUrl": "/jupyter/signalprocessing/2021/12/27/SignalProcessingPart1.html",
            "date": " • Dec 27, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "First Blog Post",
            "content": "First Blog Post . Using a new platform to write and publish my blog posts. This is the first post. Most writers post their content to platforms such as Medium. But I wanted to try something new. Fastpages is a new platform that I’m using to write and publish my content. Unlike Medium, my content created is under my control and repository. 😄 .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/markdown/2021/12/26/FirstPost.html",
            "relUrl": "/markdown/2021/12/26/FirstPost.html",
            "date": " • Dec 26, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post13": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "J&amp;J Engineering is a company with more than 10 years in the field of Manufacturing, Automation, Electrical and Software design. . We are your partner for all your automation needs: . Autocad and Electrical Drawings and design; | PE Stamping; | PLC Programming and Automation; | Software and Functional Specifications; | Descriptions of Operations; | Project Management and Project Management consulting and Audits; | Electrical Cabinet Design; | Whole Product design lifecycle. | . We are also on the forefront of the new Web 3.0. Our experienced software engineers can support and guide your strategies into this new technology: . Auditing smart contracts and ICO consulting services, you can be assured that we have the knowledge to assist you with any blockchain related project. Our team has experience working on different industries including retail, manufacturing, chemicals, oil &amp; gas and others. . We provide competitive pricing for all of our products because we believe that everyone deserves access to high quality engineering solutions at affordable prices which will not compromise their safety or wellbeing. . We are committed to providing excellent service by always being available when needed so contact us today! . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://gjunqueira-sys.github.io/J-J-Engineering-Blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}